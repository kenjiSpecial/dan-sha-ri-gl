<html>
<title>DEV</title>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
<style>
    * {
        margin: 0;
    }

    html,
    body {
        font-family: 'Roboto', sans-serif;
        width: 100%;
        height: 100%;
        overflow: hidden;
    }

    canvas {
        display: block;
    }
</style>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0" />

<body>
    <script src="../build/dsrgl.min.js"></script>
    <script src="./vendors/dat.gui.min.js"></script>
    <script src="./vendors/stats.min.js"></script>

    <script>
        const vertexShaderSrc = `
        precision highp float;
        attribute vec4 position;
        attribute vec3 normal;

        uniform mat4 uMVPMatrix;

        varying vec3 vNormal;

        void main() {
            gl_Position = uMVPMatrix * position;
            vNormal = normal;
        }`;

        const fragmentShaderSrc = `
        precision highp float;

        varying vec3 vNormal;
        void main(){
            gl_FragColor = vec4(vNormal, 1.0);
        }
        `;


        var canvas = document.createElement('canvas');
        var gl = canvas.getContext('webgl');
        document.body.appendChild(canvas);
        
        var viewportWidth, viewportHeight;
        var sphere = {}

        resize();

        var camera = new dsr.Camera(window.innerWidth, window.innerHeight, 45, 0.1, 1000); 
        camera.updatePosition(0, 0, 15);
        camera.updateLookAtPosition(0, 0, 0);
        camera.updateViewMatrix();
        
        // create sphere
        {
            var { vertices, normals, indices } = dsr.getSphere(5, 32, 32);
            sphere.progoram = dsr.createPrgoram(gl, vertexShaderSrc, fragmentShaderSrc);
            sphere.buffers = {
                position: dsr.creteBuffer(gl, sphere.progoram, new Float32Array(vertices), 'position'),
                normal: dsr.creteBuffer(gl, sphere.progoram, new Float32Array(normals), 'normal'),
                index: dsr.createIndex(gl, new Uint16Array(indices))
            };
            sphere.matrix = {
                modelMatrix: dsr.mat4.create(),
                mvMatrix: dsr.mat4.create(),
                mvpMatrix: dsr.mat4.create()
            };
            sphere.uniforms = dsr.getUniformLocations(gl, sphere.progoram, ['uMVPMatrix']);
        }

        tick();

        function resize(){
            viewportWidth = window.innerWidth;
            viewportHeight = window.innerHeight;
            canvas.width = viewportWidth;
            canvas.height = viewportHeight;

            if(camera) camera.resize(viewportHeight, viewportHeight);
        }

        function tick(){
            dsr.mat4.multiply(sphere.matrix.mvMatrix, camera.viewMatrix, sphere.matrix.modelMatrix);
            dsr.mat4.multiply(sphere.matrix.mvpMatrix, camera.projectionMatrix, sphere.matrix.mvMatrix);
        
            gl.clearColor(0, 0, 0, 1);
            gl.enable(gl.DEPTH_TEST);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.viewport(0, 0, viewportWidth, viewportHeight);

            gl.useProgram(sphere.progoram);

            dsr.bindBuffer(gl, sphere.buffers.position.buffer, sphere.buffers.position.location, 3); 
            dsr.bindBuffer(gl, sphere.buffers.normal.buffer, sphere.buffers.normal.location, 3);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphere.buffers.index.buffer);

            gl.uniformMatrix4fv(sphere.uniforms.uMVPMatrix, false, sphere.matrix.mvpMatrix);
            
            gl.drawElements(gl.TRIANGLES, sphere.buffers.index.cnt, gl.UNSIGNED_SHORT, 0);
                    
            requestAnimationFrame(tick);
        }

    </script>
</body>

</html>